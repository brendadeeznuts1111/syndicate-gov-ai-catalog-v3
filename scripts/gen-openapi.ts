#!/usr/bin/env bun
// scripts/gen-openapi.ts - Source-mapped OpenAPI forge
import { file, YAML } from 'bun';

interface RouteDecl {
  path: string;
  method: string | 'WS';
  id: string;
  handler: string;
  auth?: string;
  request?: { schema: string; required?: boolean };
  response: Record<string, { schema: string; example?: any }>;
  tags: string[];
  summary: string;
  sourcemap?: boolean;
  subprotocol?: string;
}

function parseZodToOpenAPI(zodString: string): any {
  // Simplified Zod to OpenAPI conversion
  const schemas: any = {};
  
  if (zodString.includes('z.object')) {
    const objectMatch = zodString.match(/z\.object\({([^}]+)}\)/s);
    if (objectMatch) {
      const properties: any = {};
      const fieldMatches = objectMatch[1].match(/(\w+):\s*z\.(\w+)\([^)]*\)/g);
      
      if (fieldMatches) {
        fieldMatches.forEach(field => {
          const [name, type] = field.split(':').map(s => s.trim());
          const zodType = type.match(/z\.(\w+)/)?.[1];
          
          if (name && zodType) {
            properties[name] = {
              type: zodType === 'string' ? 'string' : 
                    zodType === 'number' ? 'number' : 
                    zodType === 'boolean' ? 'boolean' : 'object'
            };
          }
        });
      }
      
      schemas['AutoGenerated'] = {
        type: 'object',
        properties
      };
    }
  }
  
  return schemas;
}

async function generateOpenAPI() {
  const startTime = performance.now();
  
  const config = YAML.parse(await file('config/bun.yaml').text());
  const routes: RouteDecl[] = config.api.routes || [];
  
  const openapi: any = {
    openapi: '3.1.0',
    info: { 
      title: config.api.openapi?.title || 'Syndicate API', 
      version: config.api.version || '1.0.0',
      description: config.api.openapi?.description || 'Bun-powered API'
    },
    servers: config.api.openapi?.servers || [],
    paths: {},
    components: { 
      schemas: {
        ConfigResponse: {
          type: 'object',
          properties: {
            hash: { type: 'string' },
            data: { type: 'string' },
            interpolated: { type: 'boolean' }
          }
        },
        StoreRequest: {
          type: 'object',
          properties: {
            yaml: { type: 'string' },
            interpolate: { type: 'boolean' }
          },
          required: ['yaml']
        },
        StoreResponse: {
          type: 'object',
          properties: {
            id: { type: 'string' },
            hash: { type: 'string' },
            path: { type: 'string' }
          }
        },
        Error: {
          type: 'object',
          properties: {
            error: { type: 'string' },
            code: { type: 'string' }
          }
        },
        YAMLString: {
          type: 'object',
          properties: {
            content: { type: 'string' }
          }
        },
        ValidationResult: {
          type: 'object',
          properties: {
            valid: { type: 'boolean' },
            errors: { type: 'array', items: { type: 'string' } }
          }
        },
        ValidationError: {
          type: 'object',
          properties: {
            error: { type: 'string' },
            details: { type: 'array', items: { type: 'string' } }
          }
        }
      },
      securitySchemes: {
        csrf: {
          type: 'apiKey',
          in: 'header',
          name: 'X-CSRF-Token'
        },
        vault: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT'
        }
      }
    },
    tags: []
  };

  await Promise.all(routes.map(async (route) => {
    if (!route.sourcemap) return;

    try {
      const handlerCode = await file(route.handler).text();
      const zodSchemas = parseZodToOpenAPI(handlerCode);
      
      // Merge auto-generated schemas
      Object.assign(openapi.components.schemas, zodSchemas);
      
      const responseSchemas: any = {};
      
      if (route.response) {
        for (const [code, res] of Object.entries(route.response)) {
          const responseDef = res as any;
          responseSchemas[code] = {
            description: `${code} response`,
            content: { 
              'application/json': { 
                schema: { $ref: `#/components/schemas/${responseDef.schema}` },
                ...(responseDef.example && { example: responseDef.example })
              }
            }
          };
        }
      } else {
        // Default response for routes without explicit response schemas
        responseSchemas['200'] = {
          description: 'Success',
          content: { 
            'application/json': { 
              schema: { type: 'object' }
            }
          }
        };
      }

      // Convert path params from {param} to OpenAPI format
      const pathKey = route.path;
      openapi.paths[pathKey] ??= {};
      
      // WebSocket endpoints are handled as GET with upgrade
      const methodKey = route.method === 'WS' ? 'get' : route.method.toLowerCase();
      
      const parameters: any[] = [];
      if (route.path.includes('{')) {
        const paramMatches = route.path.match(/{([^}]+)}/g);
        if (paramMatches) {
          paramMatches.forEach(param => {
            const name = param.slice(1, -1);
            parameters.push({
              name,
              in: 'path',
              required: true,
              schema: { type: 'string' }
            });
          });
        }
      }
      
      openapi.paths[pathKey][methodKey] = {
        summary: route.summary,
        tags: route.tags,
        operationId: route.id,
        parameters,
        requestBody: route.request ? {
          required: route.request.required || false,
          content: { 
            'application/json': { 
              schema: { $ref: `#/components/schemas/${route.request.schema}` } 
            }
          }
        } : undefined,
        responses: responseSchemas,
        security: route.auth ? [{ [route.auth]: [] }] : []
      };

      // Auto-tag deduplication
      route.tags.forEach((tag: string) => {
        if (!openapi.tags.some((t: any) => t.name === tag)) {
          openapi.tags.push({ name: tag });
        }
      });
      
    } catch (error) {
      console.warn(`‚ö†Ô∏è Could not process route ${route.id}: ${error.message}`);
    }
  }));

  // Write OpenAPI spec
  const yamlSpec = YAML.stringify(openapi);
  await file(config.api.openapi?.output || './docs/openapi.yaml').write(yamlSpec);
  
  const genTime = performance.now() - startTime;
  console.log(`üü¢ OpenAPI spec forged: ${config.api.openapi?.output || './docs/openapi.yaml'} (${yamlSpec.length} bytes, ${genTime.toFixed(1)}ms)`);
}

// CLI execution
if (import.meta.main) {
  generateOpenAPI().catch(console.error);
}

export { generateOpenAPI };
